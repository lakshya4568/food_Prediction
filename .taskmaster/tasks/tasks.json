{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Next.js Frontend & Multi-Page Routing",
        "description": "Initialize the Next.js project with Tailwind CSS and create the main page structure for the application as specified in the PRD.",
        "details": "Create core pages in `/pages`: `dashboard.js`, `planner.js`, `grocery.js`, `health-docs.js`, and `settings.js`. Implement basic navigation between them. Use Next.js `dynamic` imports for components and add loading skeletons with Tailwind placeholders.",
        "testStrategy": "Run `npm run dev` and verify that all created pages are accessible via browser navigation and that clicking links between them works correctly. Check for loading skeletons on slow component loads.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create App Router Page Structures for New Pages",
            "description": "Create the folder and file structure for the missing pages (Planner, Grocery, Health Docs, Settings) using the Next.js App Router conventions.",
            "dependencies": [],
            "details": "For each new section, create a directory inside `/app` (e.g., `/app/planner/`, `/app/grocery/`, etc.). Inside each directory, create a `page.tsx` file with a basic placeholder React component that renders a unique heading (e.g., `<h1>Planner Page</h1>`).\n<info added on 2025-08-05T06:05:38.655Z>\n---\n**USER UPDATE: Subtask 1.1 Completed**\n\n**Implementation Summary:**\n- Created four complete page structures in the `/app` directory: `/planner`, `/grocery`, `/health-docs`, and `/settings`.\n- Instead of basic placeholders, each page was built as a functional React component with a consistent layout (Header, main content, Footer), `use client` directives, and a comprehensive UI featuring mock data and interactive elements styled with TailwindCSS.\n\n**Testing:**\n- All new routes are accessible and render without errors on the development server.\n\n**Next Steps:**\n- Ready to proceed to subtask 1.2 (Implement Consistent Page Layout), noting that much of this work has already been done as part of this subtask's implementation.\n</info added on 2025-08-05T06:05:38.655Z>",
            "status": "done",
            "testStrategy": "Run `npm run dev` and manually navigate to `/planner`, `/grocery`, `/health-docs`, and `/settings` in the browser to verify that each route loads its corresponding placeholder page."
          },
          {
            "id": 2,
            "title": "Implement Consistent Page Layout",
            "description": "Create a shared layout component to wrap the main application pages, ensuring a consistent header, footer, and content area styling across all new and existing pages.",
            "dependencies": [
              "1.1"
            ],
            "details": "Create a route group `(main)` in the `/app` directory. Move the existing `dashboard` page and the new page directories from subtask 1.1 into `/app/(main)/`. Create a `layout.tsx` in `/app/(main)/` that imports and renders the shared Header and Footer components, with the `{children}` prop rendered in a main content container styled with Tailwind CSS for consistent padding and max-width.\n<info added on 2025-08-05T07:45:04.870Z>\nA route group `(main)` was created in the `/app` directory, and all main pages (`dashboard`, `planner`, `grocery`, `health-docs`, `settings`) were moved into it. A new shared layout file, `/app/(main)/layout.jsx`, was implemented to provide a consistent structure for these pages. This layout renders the `<Header />`, a `<main className=\"min-h-screen pt-16\">{children}</main>` container, and the `<Footer />`. Consequently, all individual page components were refactored to remove their now-redundant Header and Footer imports.\n</info added on 2025-08-05T07:45:04.870Z>",
            "status": "done",
            "testStrategy": "Navigate between `/dashboard`, `/planner`, and `/grocery`. Verify that the header, footer, and main content styling are identical on all pages."
          },
          {
            "id": 3,
            "title": "Update Header with Active Navigation Links",
            "description": "Modify the existing Header component to include navigation links to all main pages and visually indicate the currently active page.",
            "dependencies": [
              "1.1"
            ],
            "details": "In the Header component, use the Next.js `<Link>` component to add navigation items for Planner, Grocery, Health Docs, and Settings. Use the `usePathname` hook to conditionally apply a specific Tailwind CSS class (e.g., `font-bold`, `underline`) to the link corresponding to the current URL.\n<info added on 2025-08-05T07:52:50.986Z>\n**Implementation Notes:**\n- A `navItems` array was created to manage navigation links for: Dashboard, Planner, Grocery, Health Docs, and Settings.\n- Active link state is managed using the `usePathname` hook in conjunction with `isActiveLink()` and `getLinkClasses()` helper functions.\n- Specific Tailwind CSS classes were applied for link states:\n  - **Active:** `text-primary-600 font-semibold border-b-2 border-primary-600`\n  - **Inactive:** `text-gray-700 hover:text-primary-500`\n- The active state logic was implemented for both the desktop navigation bar and the mobile hamburger menu.\n- The mobile menu was enhanced with a click handler to automatically close after a navigation item is selected.\n- The user actions section of the header was updated with \"Predict Food\" and \"Profile\" buttons.\n</info added on 2025-08-05T07:52:50.986Z>",
            "status": "done",
            "testStrategy": "Click each link in the header and confirm it navigates to the correct page without a full page reload. Verify that the style of the link for the active page is visually distinct from the others."
          },
          {
            "id": 4,
            "title": "Implement Loading Skeletons and Error Boundaries",
            "description": "Add loading and error handling UI for the new pages using Next.js App Router file conventions to improve user experience during navigation and on error.",
            "dependencies": [
              "1.1"
            ],
            "details": "In each new page directory (e.g., `/app/planner/`), create a `loading.tsx` file containing a basic skeleton component styled with Tailwind's `animate-pulse` classes. Create a single `error.tsx` file in the `app/(main)/` directory to act as a centralized error boundary for all main pages, displaying a user-friendly error message and a 'Try Again' button.\n<info added on 2025-08-05T08:28:02.242Z>\n**Implementation Summary:**\n- Created comprehensive loading skeletons for all main pages, mirroring the structure of the actual page components and using Tailwind's `animate-pulse` for the animation.\n  - `src/app/(main)/dashboard/loading.tsx`\n  - `src/app/(main)/planner/loading.tsx`\n  - `src/app/(main)/grocery/loading.tsx`\n  - `src/app/(main)/health-docs/loading.tsx`\n  - `src/app/(main)/settings/loading.tsx`\n- Implemented a single, centralized error boundary at `src/app/(main)/error.tsx` as a client component (`\"use client\"`).\n- The error component includes the required 'Try Again' button, plus additional user-friendly features: a 'Go to Dashboard' fallback link, development-mode error details, and contact support information.\n- Used `react-icons/fa` for consistent iconography in the error component.\n</info added on 2025-08-05T08:28:02.242Z>",
            "status": "done",
            "testStrategy": "Simulate a delay in a page component to verify its loading skeleton appears. Intentionally throw an error from a page component to verify the shared error boundary UI is rendered correctly."
          },
          {
            "id": 5,
            "title": "Refactor Placeholders with Dynamically Imported Components",
            "description": "Replace the initial placeholder content on the new pages with actual UI components that are loaded dynamically to optimize initial page load.",
            "dependencies": [
              "1.1",
              "1.4"
            ],
            "details": "For each page, create its main UI component (e.g., `components/planner/PlannerView.tsx`). In the corresponding `page.tsx` file, import the component using `next/dynamic`. Configure the dynamic import to be client-side only (`ssr: false`) and to use the page-specific loading skeleton created in subtask 1.4.\n<info added on 2025-08-05T08:42:32.145Z>\nThe following dedicated page components have been created and placed in `/src/components/`:\n- `DashboardContent.jsx`\n- `PlannerContent.jsx`\n- `GroceryContent.jsx`\n- `HealthDocsContent.jsx`\n- `SettingsContent.jsx`\n\nAll corresponding `page.jsx` files within `/src/app/(main)/` have been updated to use `next/dynamic` to import these components. The dynamic imports are configured with `ssr: false` and integrate the appropriate loading skeletons, achieving per-page code splitting and lazy loading.\n\nThe resulting file structure is:\n```\nsrc/\n├── app/(main)/\n│   ├── dashboard/\n│   │   ├── page.jsx (dynamic import)\n│   │   └── loading.tsx (skeleton)\n│   ├── planner/\n│   │   ├── page.jsx (dynamic import)\n│   │   └── loading.tsx (skeleton)\n│   ├── grocery/\n│   │   ├── page.jsx (dynamic import)\n│   │   └── loading.tsx (skeleton)\n│   ├── health-docs/\n│   │   ├── page.jsx (dynamic import)\n│   │   └── loading.tsx (skeleton)\n│   ├── settings/\n│   │   ├── page.jsx (dynamic import)\n│   │   └── loading.tsx (skeleton)\n│   └── error.tsx (centralized error boundary)\n└── components/\n    ├── DashboardContent.jsx\n    ├── PlannerContent.jsx\n    ├── GroceryContent.jsx\n    ├── HealthDocsContent.jsx\n    └── SettingsContent.jsx\n```\n</info added on 2025-08-05T08:42:32.145Z>",
            "status": "done",
            "testStrategy": "Using browser developer tools, check the Network tab to confirm that the JavaScript for a specific page's component is only fetched upon navigating to that page. The loading skeleton should be visible briefly before the main component appears."
          }
        ]
      },
      {
        "id": 2,
        "title": "Build Modern UI Components",
        "description": "Develop reusable UI components like cards, buttons, and a file upload zone using Tailwind CSS to establish the application's visual style.",
        "details": "Style components with Tailwind utility classes, including gradients (e.g., `bg-gradient-to-r`), shadows, and transitions. Implement a drag-and-drop file upload zone with visual feedback and a progress bar.",
        "testStrategy": "Create a test page or use Storybook to render and visually inspect all components. Verify hover effects and that the file upload zone responds to drag events.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Reusable Button Component",
            "description": "Develop a primary, reusable button component styled with Tailwind CSS, including all interactive states.",
            "dependencies": [],
            "details": "Implement the button using Tailwind utility classes. It must feature a gradient background (`bg-gradient-to-r`), a subtle shadow, and smooth transitions for `hover` and `active` states. Ensure a disabled state is also styled.",
            "status": "pending",
            "testStrategy": "Render the button in various states (default, hover, active, disabled) on a test page or in Storybook to visually verify the styles and transitions."
          },
          {
            "id": 2,
            "title": "Build a Versatile Card Component",
            "description": "Construct a reusable card component for displaying content, styled with modern aesthetics using Tailwind CSS.",
            "dependencies": [],
            "details": "Design a flexible card layout with rounded corners, shadows, and appropriate padding. The structure should be generic enough to hold various content types, such as text, lists, or other components.",
            "status": "pending",
            "testStrategy": "Populate the card component with sample data on a test page/Storybook to ensure the layout is clean, responsive, and visually appealing."
          },
          {
            "id": 3,
            "title": "Implement Drag-and-Drop Zone UI and Event Handling",
            "description": "Create the UI for the file upload zone and implement the client-side logic to handle drag-and-drop events with visual feedback.",
            "dependencies": [],
            "details": "Build the drop zone layout with instructive text. Use JavaScript to listen for `dragenter`, `dragleave`, and `drop` events. Apply conditional Tailwind classes to change the border style or background color when a file is dragged over the area.",
            "status": "pending",
            "testStrategy": "Drag a file over the component to verify the visual feedback appears. Drop a file and confirm the `drop` event is captured by logging the file details to the console."
          },
          {
            "id": 4,
            "title": "Develop File Upload Progress Bar",
            "description": "Create a dynamic progress bar component to provide visual feedback during a file upload.",
            "dependencies": [],
            "details": "Style a progress bar component using Tailwind CSS. It should consist of an outer container and an inner bar whose width is controlled by a prop (e.g., a percentage value). This component will be placed within the file upload zone.",
            "status": "pending",
            "testStrategy": "Render the progress bar component independently and pass different percentage values (e.g., 0, 50, 100) to it, verifying its width updates correctly."
          },
          {
            "id": 5,
            "title": "Assemble and Test Components on a Showcase Page",
            "description": "Integrate all created UI components onto a single showcase page or Storybook to verify their appearance and functionality together.",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.4"
            ],
            "details": "Create a new page/route to display the button, card, and the complete file upload zone (including the progress bar). This page will serve as the final visual review and testing ground for the components.",
            "status": "pending",
            "testStrategy": "Load the showcase page. Verify all components render correctly. Test button hover effects and the drag-and-drop functionality of the upload zone to ensure all parts work as intended."
          }
        ]
      },
      {
        "id": 3,
        "title": "Setup Node.js Backend & Postgres Database",
        "description": "Initialize a new Node.js/Express server to handle non-ML backend logic and connect it to a local Postgres database with the required schema.",
        "details": "Create a `server.js` file for the Express app. Establish a connection to a local Postgres instance (e.g., `postgresql://localhost/nutrivision`). Define and create the `users` and `meals` tables as specified in the PRD.",
        "testStrategy": "Start the Node.js server and confirm it connects to the database without errors. Use a database client to verify that the `users` and `meals` tables have been created with the correct columns.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement JWT-based Authentication",
        "description": "Create registration and login endpoints on the Node.js server that issue JSON Web Tokens (JWTs), and secure pages/APIs.",
        "details": "Develop `/api/auth/register` and `/api/auth/login` endpoints. Upon successful login, return a JWT and store it in a secure-http-only cookie. Implement Express middleware to verify the JWT on protected routes. Use `getServerSideProps` in Next.js to check for the cookie and redirect if unauthorized.",
        "testStrategy": "Use Postman or a similar tool to hit the register and login endpoints. Verify a JWT is returned. Attempt to access a protected API endpoint without the token (should fail) and with the token (should succeed).",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Manage User Health Profile",
        "description": "Build API endpoints and a UI on the settings page to allow authenticated users to store, fetch, and update their health profile data.",
        "details": "Create a `/api/profile` endpoint (PUT/GET) to handle JSON data for age, gender, allergies, etc. Build a form on the `settings.js` page to submit this data. Use the Next.js Context API to make this profile data available globally on the client-side.",
        "testStrategy": "Log in as a user, navigate to the settings page, fill out and submit the profile form. Refresh the page or navigate away and back to confirm the data has been saved and is displayed correctly.",
        "priority": "medium",
        "dependencies": [
          1,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Backend API Endpoints for Health Profile",
            "description": "Develop the Node.js API routes at `/api/profile` to handle fetching (GET) and updating (PUT) a user's health profile data. This includes defining the database schema for the profile and implementing the logic to store/retrieve it.",
            "dependencies": [],
            "details": "Implement two Express route handlers: `GET /api/profile` to retrieve the current user's profile and `PUT /api/profile` to create or update it. The PUT handler should validate the incoming JSON data (age, gender, allergies). Initially, this can be developed without authentication.",
            "status": "pending",
            "testStrategy": "Use Postman or a similar tool to send GET and PUT requests to the endpoints with a hardcoded user ID to verify that data is saved and retrieved correctly from the database."
          },
          {
            "id": 2,
            "title": "Secure Profile API Endpoints with JWT Authentication",
            "description": "Integrate the JWT authentication middleware (from Task 4) to protect the `/api/profile` endpoints, ensuring only the authenticated user can access and modify their own data.",
            "dependencies": [
              "5.1"
            ],
            "details": "Apply the JWT verification middleware to the profile route group. Modify the route handlers to extract the `userId` from the decoded JWT payload and use it in database queries, replacing any hardcoded user IDs.",
            "status": "pending",
            "testStrategy": "Attempt to access the endpoints without a valid JWT (expect 401 Unauthorized). Then, use a valid JWT from the login endpoint to successfully GET and PUT data, verifying the action is tied to the correct user."
          },
          {
            "id": 3,
            "title": "Build the Health Profile Form UI on Settings Page",
            "description": "Develop the user interface for the health profile form within the `settings.js` Next.js page. The form should include input fields for age, gender, allergies, and other relevant health data.",
            "dependencies": [],
            "details": "Using reusable components (from Task 2) and Tailwind CSS, build a responsive form. Include fields like a number input for age, a select dropdown for gender, and a text area for allergies. Add a submit button and elements for user feedback (e.g., success/error messages).",
            "status": "pending",
            "testStrategy": "Render the `settings.js` page and visually inspect the form on different screen sizes. Verify all form elements are present, styled correctly, and responsive."
          },
          {
            "id": 4,
            "title": "Implement Client-Side Logic for Form Data Handling",
            "description": "Write the client-side JavaScript in `settings.js` to connect the UI form to the backend API. This includes fetching existing data to populate the form and handling the submission of new data.",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "Use a `useEffect` hook to call the `GET /api/profile` endpoint when the component mounts and use the response to set the form's initial state. Create an `onSubmit` handler that sends a `PUT` request with the form data to `/api/profile`.",
            "status": "pending",
            "testStrategy": "Log in and navigate to the settings page. Verify the form is pre-filled with the user's data. Update the data, submit the form, and refresh the page to confirm the new data persists."
          },
          {
            "id": 5,
            "title": "Create and Integrate a Global Profile Context",
            "description": "Implement a React Context using the Next.js Context API to store the user's health profile data globally, making it accessible to other components without re-fetching.",
            "dependencies": [
              "5.2"
            ],
            "details": "Create a `ProfileContext.js` file with a `ProfileProvider` component. This provider will fetch data from `GET /api/profile` and make it available. Wrap the main `_app.js` layout with this provider. Create a `useProfile` custom hook for easy consumption.",
            "status": "pending",
            "testStrategy": "After logging in, verify that a separate component (e.g., the main dashboard) can access the profile data using the `useProfile` hook. Update the profile on the settings page and confirm the context value updates globally without a page refresh."
          }
        ]
      },
      {
        "id": 6,
        "title": "Integrate Nutrition Lookup via USDA API",
        "description": "Create a Node.js endpoint to fetch nutritional data from the free USDA API and display it in the UI after a food is identified by the Flask service.",
        "details": "Implement a Node.js endpoint `/api/nutri` that takes a food name, queries the USDA API, and returns a normalized JSON object. In the frontend, after receiving a prediction from Flask, call this endpoint and display the nutrition data in a UI card.",
        "testStrategy": "Manually call the `/api/nutri` endpoint with a food name like 'apple' and verify it returns structured nutritional data. In the UI, simulate a prediction and ensure the subsequent call to the nutrition endpoint populates the UI correctly.",
        "priority": "low",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Develop Health Rating System",
        "description": "Implement a backend service to calculate a health rating (A-E) for meals based on their nutritional data and the user's health profile.",
        "details": "Create a Node.js endpoint `/api/rating` that accepts nutritional data and a user ID. The logic should score the food against the user's goals (from their profile) and return a grade. Display this grade as a colored badge in the UI.",
        "testStrategy": "Call the `/api/rating` endpoint with sample meal data for two different user profiles (e.g., one with a low-sodium goal). Verify the returned rating is different and appropriate for each profile.",
        "priority": "low",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Medical Document Uploader and Parser",
        "description": "Allow users to upload medical documents, perform client-side OCR, and use Gemini to extract structured data.",
        "details": "On the `health-docs` page, use Tesseract.js for client-side OCR on uploaded PDF/PNG files. Send the extracted text to a Node.js endpoint `/api/upload-doc`, which then calls the Gemini API for parsing. Store the resulting JSON in the user's profile and display it.",
        "testStrategy": "Upload a sample medical document (e.g., a lab result PDF). Verify that the OCR text is generated and that the `health-docs` page displays structured data (e.g., diagnoses, medications) returned from the backend.",
        "priority": "low",
        "dependencies": [
          2,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Create Grocery List Generator",
        "description": "Build a feature that aggregates ingredients from a user's saved meals and generates a consolidated grocery list.",
        "details": "Create a Node.js endpoint `/api/grocery` that queries the `meals` table for a given user, aggregates all ingredients, and optimizes units. On the `grocery.js` page, add a button to trigger this generation and display the list, with an option to export as text.",
        "testStrategy": "Add several meals for a user. Navigate to the grocery page and click the generate button. Verify the output list correctly aggregates ingredients from all the meals (e.g., '100g rice' + '150g rice' becomes '250g rice').",
        "priority": "low",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Micro-Interactions & Accessibility",
        "description": "Enhance user experience with animations for loading states and feedback, while ensuring basic accessibility standards are met.",
        "details": "Use Tailwind's `animate-pulse` for loading skeletons during data fetches. Implement toast notifications for success/error messages. Add ARIA attributes to interactive elements like forms and buttons. Ensure logical tab navigation.",
        "testStrategy": "Trigger a data fetch and verify a loading animation appears. Test that form submissions show a success/error toast. Use a keyboard to navigate through a page and ensure all interactive elements are focusable in a logical order.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-05T04:02:20.857Z",
      "updated": "2025-08-05T08:42:59.444Z",
      "description": "Tasks for master context"
    }
  }
}